This folder/repository mostly contains code from high school. I can’t reveal my code from the University of Michigan or the University of Virginia because of honor code reasons. I also can’t display my code from my internships either. However, I believe my code from high school still shows my abilities. Looking back at my code now, after working in teams at internships, I realize it might not be as structured for working with groups as I would like, but it still conveys my potential and experience in coding. Artificial Intelligence, Parallel Computing, and Web Development are classes I took in Junior Year, while the others are from my Senior Year. I also took a Mobile App Development class in my Junior Year, but I no longer have access to that code. The programming languages I used for these classes were mostly python, java, C++, C, html, css, javascript, jquery, php, and mysql.

While at the University of Virginia, I wrote a program that could make complex assumptions and predictions based on previous information and actions fed into it. I also wrote a program that could play Ticket to Ride and it ended up getting to the semi-finals for an in class competition. Another example from that class is a program that could successfully negotiate with people based on weighted personal values. This class used java and python.

From the University of Michigan, I created many classes for data structures. Then I used these various data structures to complete various interesting labs such as creating an image resizer to shrink and get rid of the least important part of pictures. Some of the data structures I created were vectors, doubly linked lists, stacks, queues, binary search trees, normal trees, heaps, hashes, sets, maps, and more. I also dealt with a lot of memory aspects of these programs. I used C++ for these labs.

### Artificial Intelligence:

**Agent Based Modeling** – The sync.py and sync2.py files both use agent based modeling in order to make each separate object react to its surrounding until every object is synced up in the same pattern. The goodGraph.py and xNegCubed.py help to keep track of information and produce data for graphs to represent patterns. This information is displayed in final.pdf.

**Ghost** – ghost.txt contains every dictionary word. ghostGame.py was my original program with the user interface where two or more people could play each other in ghost. The ghostGameUpdate.py made it possible to add the computer as a player to the game as well. At first the computer just searched for words that wouldn’t make it die, but in the final product it recursively searched a tree of the words in order to find the word that has the highest probability of leading to victory. This computer often times would beat the user.

**Image Processing** – imageProcessing.py is where all the code is for this folder. This program is able to take in a normal image and modify it in many ways. At first, I made it able to make an image black and white and slightly blurred in order to get rid of the image noise. This then allowed me to do edge detection using two different methods: sobel and canny edge detection. Then I made it possible for the program to find circles and lines in the image. The exampleLineDetections.docx shows how my sobel and canny programs worked on a picture of the beach. All of the other files in the folder are pictures that are good to run in the program to see how it finds all the edges, circles, and lines.

**Neural Networks** – The firstNN.py file is the code for the neural networks of NOT, AND, and OR. The results of this code are displayed in firstNeuralDoc.docx. The xor.py file is the code for the XOR neural network. It uses weighted neural networks. The XORprintout.pptx displays the results from xor.py, as well as a diagram of the weighted neural network used.

**Optimization** – queens.py and nQueensProblem.py both show slightly different ways of solving the n-Queens problem. Both use some recursion, however nQueensProblem.py uses a bit more of it. geneticQueens.py solves the n-Queens problem using genetic algorithms. geneticQueensDoc.docx explains how I did it. I also used genetic algorithms as well as hill climbing to solve the traveling salesperson problem. These are represented in the remaining files. Loc38.txt contains the location of places in Romania, while loc734.txt contains the location of places in Uruguay. The graphs.docx represents results from different methods of hill climbing. The travelingSalesman.py contains my code for my fastest version/solution of the traveling salesperson problem.

**Othello** – othello.py is my main code file. It contains the code for the user interface of Othello, as well as the code for the computer to play the game. Most of the other files are either used to moderate and run the games or they were stepping stones to my final file of othello.py. The ImprovementLog.docx helps to explain the reason behind my methods and how I made the computer play as well as it did and gives the stats on just how well it did.

**Romania Problem** – The txt files give the necessary information about each city in Romania. The picture is just an image of approximately where each city is. The code files each contain different methods for finding the fastest paths or the most efficient ways to find cities and information such as astar, Dijkstra, breadth first search, and depth first search.

**Sudoku** – sudoku.py was my original code for solving sudoku puzzles and sudoku2.py built off of that. Sudorun.txt shows the 3 puzzles that took the longest. The other two txt files contain the puzzles that my program solved in about 3 seconds total. The csv file shows the runtimes for each puzzle and the ExplanationDoc.docx explains my reasoning and what I did in order to make my program as fast as it was.

**US Connection** – This folder is pretty much the same as the Romania Problem except it was with cities from the United States.

### Parallel Computing:
For parallel computing most of my code was on the school servers so I don’t have records of most of it. However, Gfire.c and CUDA.txy both have examples of me running code on several servers at once. There is also an example of a makefile I used and a tree class. The word document contains graphs of how much faster my code ran when expanded to more servers. The pdf file explains how I went about solving one of the problems using parallel computing. A couple other notable labs that I wasn’t able to save were programs that generated the Mandelbrot Set and the Game of Life while running on parallel servers.

### Web Development:
This file contains the code for the labs that I happened to save locally from my Web Development class. Lab 1 deals with creating an online quiz. Lab 2 loops through the DOM elements when certain parts of the screen are clicked on. Lab 3 was a form, and in a later lab (lab 5) php and mysql were used to store this information. Lab 4 dealt with regex and more data manipulation with words. Lab6/WeatherAPI read a json/xml file from an open weather API and displayed it to the user based on their location/zip code. There was also some basic d3 code examples as well for animating websites with well-displayed graphs.

### Computer Systems Senior Research Lab (SysLab):
This code was developed throughout my senior year in my computer science research lab. The two PowerPoints show the main overview of my project and the progress I had made a little over halfway through the year. The journal document kept track of my progress and some of my thoughts through April. The syslabPaper document has a more in depth explanation of my reasoning and thought process behind the project as well as how successful it ended up being. A lot of the other files in this folder show my original ideas and program starts as well as times when I debugged errors. The files inside the webConfig folder are my final files that worked completely. They are all inside this folder because this is where my code ran on a the server in order to allow the website and python files to communicate.

### Computer Vision:
Most of my files for this class remained on the school servers, however I still have a couple. Lab7.cpp contained my main code for the sieve algorithm. Point.h contained the point class that I used in the other file. The word doc contains graphs about the different version of my algorithms and their runtime including iteration, recursion, and the sieve algorithm.

### Cryptography:
The titles of most of these files explain the type of cipher that they encode/decode. Each of the folders also contain files that contain code for classes or drivers that encode and decode different complicated ciphers. Some of them also contain word documents that explain my thinking and explanations for the code. While this code might not be the most difficult to write, it still shows my understanding of modular arithmetic and basic computer security skills.
